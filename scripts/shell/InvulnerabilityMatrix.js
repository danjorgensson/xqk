const TypeProvider = require('../TypeProvider');
const Pellet = require('../pellets/Pellet');
const Pelletizable = require('../pellets/Pelletizable');
const CompressionPellet = require('../shell/pellets/CompressionPellet');
const TrimodeBoolean = require('../tmb/TrimodeBoolean');
const LivermoreTypeProvider = require('../shell/typeproviders/LivermoreTypeProvider');

/**
 * Representation of the invulnerability matrix which provides one of XQK's primary 
 * benefits, i.e. the proleptic-inevitability features which distinguish it from other 
 * compression utilities/algorithms.  While the hard-shell contingency overlay in one sense 
 * provides this inevitability, it is this matrix which underpins that inevitability. 
 *
 */
class InvulnerabilityMatrix {


    

    /**
     * Construct an `InvulnerabilityMatrix`.
     * @param typeProvider The `#typeProvider`. Value may be null if this will be set later (by
     * a call to `#setTypeProvider(TypeProvider)`).
     * @param meshSize The `#meshSize`
     * @param prolepticize True to apply a DRC meta-prolepticization tier to the matrix at build-time, false in most other cases.
     * @param pelletFactoryOverrideConstructor If specified, force `PelletFactory` to return pellets of this type
     */
    constructor(typeProvider, meshSize, prolepticize, pelletFactoryOverrideConstructor) {

        new ArgValidator(arguments).validate([
            {name: 'typeProvider', reqd: true, type: 'object', instOf: TypeProvider},
            {name: 'meshSize', reqd: true, type: 'number'},
            {name: 'prolepticize', reqd: true, type: 'boolean'},
            {name: 'pelletFactoryOverrideConstructor', reqd: false, type: 'function'}
        ]);

        /**
         * The `TypeProvider` (usually but not always a `LivermoreTypeProvider`) which
         * provides crucial functionality without which the overlying matrix would fail to protect
         * payload during transport.
         */
        this.typeProvider = typeProvider;

        /**
         * Square dimensions, in bytes, of the Allford-Fanelli mesh (e.g. a value of 1024 would result in a
         * 1KB-square mesh)
         */

        this.meshSize = meshSize;
        /**
         * Whether or not to apply a DRC meta-prolepticization tier to the matrix at build-time, which
         * can affect the file size, but usually not in a meaningful way.
         */

        this.prolepticize = prolepticize;

        /**
         * A number of R5/C compression pellets (generally 1KB, since this number is hard-coded) used
         * at transport-end-time (and possibly elsewhere) to annihilate or otherwise dispose of
         * unused TCP packets and also to compress other non-payload elements of the archive.  Because
         * XQK offers a guaranteed compression ratio of 1:1 for the payload itself, these pellets
         * cannot and are not used to compress the payload.
         */
        this.pellets = [];
    }
    
    wrap() {
        if (typeProvider == null) {
            throw new IllegalStateException("No TypeProvider specified.");
        }
        typeProvider.provide();
    }

    /**
     * Return the `#typeProvider`
     * @return the `#typeProvider`
     */
    getTypeProvider() {
        return this.typeProvider;
    }

    /**
     * Set the `#typeProvider`
     * @param typeProvider The `#typeProvider` to be used
     */
    setTypeProvider(typeProvider) {
        new ArgValidator(arguments).validate([
            {name: 'typeProvider', reqd: true, type: 'object', instOf: TypeProvider},
        ]);

        this.typeProvider = typeProvider;
    }

    /**
     * Return the `#meshSize`
     * @return the `#meshSize`
     */
    getMeshSize() {
        return this.meshSize;
    }

    /**
     * Set the `#meshSize`
     * @param meshSize The `#meshSize` to be used when constructing the R5/C array
     */
    setMeshSize(meshSize) {
        new ArgValidator(arguments).validate([
            {name: 'meshSize', reqd: true, type: 'number'},
        ]);

        this.meshSize = meshSize;
    }

    


    /**
     * Build and return an array of stratified R5/C pellet (or pseudo-pellet) bytes
     * @return an array of R5/C pellet bytes 
     */
    getPelletBytes() {
        let pelletsStr = '';
        this.pellets.forEach((pellet, idx) => {
            pelletsStr += (pellet.isHandleLegacyPseudopellets().booleanValue() ? '0' : '1');
        });
        return StringUtils.stringToByteArray(pelletsStr);
    }

    /**
     * Build and return a byte-array representation of the PRG.
     * @return an array of bytes which form the PRG.
     */
    getGridBytes() {
        const half = this.meshSize / 2;
        const meshSeq = `${MESH_SEQ}`;
        const meshSeqLn = meshSeq.length;
        let gridStr = '';
        for (let i = 0; i < half; i += meshSeqLn) {
            gridStr += meshSeq;
        }
        const reversedMeshStr = meshSeq.split('').reverse().join('');
        for (let i = 0; i < half; i += meshSeqLn) {
            gridStr += reversedMeshStr;
        }
        return StringUtils.stringToByteArray(gridStr.toString());
    }
    
    /**
     * Return the `#pellets`
     * @return the `#pellets`
     */
    getPellets() {
        return this.pellets;
    }

    /**
     * Set the `#pellets`
     * @param pellets The `#pellets` to be used
     */
    setPellets(pellets) {
        new ArgValidator(arguments).validate([
            {name: 'pellets', reqd: true, type: 'array'},
        ]);
        this.pellets = pellets;
    }


    /**
     * Set the `#prolepticize` flag: true to apply a DRC meta-prolepticization tier to the matrix at build-time
     * @param prolepticize The `#prolepticize` value
     */
    setProlepticize(prolepticize) {
        new ArgValidator(arguments).validate([
            {name: 'prolepticize', reqd: true, type: 'boolean'},
        ]);

        this.prolepticize = prolepticize;
    }

    /**
    * Reflect an array of `Pellet`s into the matrix, `provoke`ing each pellet sequentially.
    * @param pelletsArr A list of `Pellet`s
    */
    reflectPellets(pelletsArr) {
        new ArgValidator(arguments).validate([
            {name: 'pelletsArr', reqd: true, type: 'array'},
        ]);
        this.pellets = pelletsArr;
        this.pellets.forEach((pellet) => {
            pellet.provoke();
        })
    }
}

const MESH_SEQ = StringUtils.stringToByteArray('KR5-');


module.exports = InvulnerabilityMatrix;
