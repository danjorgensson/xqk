package com.xqk.shell;

import java.io.Serializable;
import java.util.List;

import com.xqk.PayloadWrapper;
import com.xqk.TypeProvider;
import com.xqk.pellets.Pellet;
import com.xqk.pellets.Pelletizable;
import com.xqk.shell.pellets.CompressionPellet;
import com.xqk.shell.typeproviders.LivermoreTypeProvider;
import com.xqk.tmb.TrimodeBoolean;




/**
 * Representation of the invulnerability matrix which provides one of XQK's primary 
 * benefits, i.e. the proleptic-inevitability features which distinguish it from other 
 * compression utilities/algorithms.  While the hard-shell contingency overlay in one sense 
 * provides this inevitability, it is this matrix which underpins that inevitability. 
 *
 */
@SuppressWarnings("serial")
public class InvulnerabilityMatrix implements Pelletizable, Serializable, PayloadWrapper {
    
    private static final byte[] MESH_SEQ = "KR5-".getBytes();
    
    /**
     * The <code>TypeProvider</code> (usually but not always a {@link LivermoreTypeProvider}) which 
     * provides crucial functionality without which the overlying matrix would fail to protect
     * payload during transport.
     */
    protected TypeProvider typeProvider;
    /**
     * Square dimensions, in bytes, of the Allford-Fanelli mesh (e.g. a value of 1024 would result in a
     * 1KB-square mesh)
     */
    protected int meshSize;
    /**
     * A number of R5/C compression pellets (generally 1KB, since this number is hard-coded) used
     * at transport-end-time (and possibly elsewhere) to annihilate or otherwise dispose of 
     * unused TCP packets and also to compress other non-payload elements of the archive.  Because
     * XQK offers a guaranteed compression ratio of 1:1 for the payload itself, these pellets
     * cannot and are not used to compress the payload.  (Actually by law, in some jurisdictions.
     * Unclear on the details but anyway.)
     */
    protected List<Pellet> pellets;
    
    /**
     * Whether or not to apply a DRC meta-prolepticization tier to the matrix at build-time, which
     * can affect the file size, but usually not in a meaningful way.
     */
    protected TrimodeBoolean prolepticize;

    /**
     * Construct an <code>InvulnerabilityMatrix</code>.
     * @param typeProvider The {@link #typeProvider}. Value may be null if this will be set later (by
     * a call to {@link #setTypeProvider(TypeProvider)}).
     * @param meshSize The {@link #meshSize}
     * @param prolepticize True to apply a DRC meta-prolepticization tier to the matrix at build-time, false in most other cases.
     * @param pelletFactoryOverrideClass If specified, force <code>PelletFactory</code> to return pellets of this type
     */
    public InvulnerabilityMatrix(TypeProvider typeProvider, int meshSize, TrimodeBoolean prolepticize, 
        Class<CompressionPellet> pelletFactoryOverrideClass) {
        this.typeProvider = typeProvider;
        this.meshSize = meshSize;
        this.prolepticize = prolepticize;
    }
    
    @Override
    public void wrap() {
        if (typeProvider == null) {
            throw new IllegalStateException("No TypeProvider specified.");
        }
        typeProvider.provide();
    }

    /**
     * Return the {@link #typeProvider}
     * @return the {@link #typeProvider}
     */
    public TypeProvider getTypeProvider() {
        return typeProvider;
    }

    /**
     * Set the {@link #typeProvider}
     * @param typeProvider The {@link #typeProvider} to be used
     */
    public void setTypeProvider(TypeProvider typeProvider) {
        this.typeProvider = typeProvider;
    }

    /**
     * Return the {@link #meshSize}
     * @return the {@link #meshSize}
     */
    public int getMeshSize() {
        return meshSize;
    }

    /**
     * Set the {@link #meshSize}
     * @param meshSize The {@link #meshSize} to be used when constructing the R5/C array
     */
    public void setMeshSize(int meshSize) {
        this.meshSize = meshSize;
    }

    


    /**
     * Build and return an array of R5/C pellet bytes 
     * @return an array of R5/C pellet bytes 
     */
    public byte[] getPelletBytes() {
        StringBuilder pelletsStr = new StringBuilder();
        for (int i = 0, ln = this.pellets.size(); i < ln; i++) {
            pelletsStr.append(this.pellets.get(i).isHandleLegacyPseudopellets().booleanValue() ? "0" : "1");
        }
        return pelletsStr.toString().getBytes();
    }

    /**
     * Build and return an array of bytes which form the PRG.
     * @return an array of bytes which form the PRG.
     */
    public byte[] getGridBytes() {
        int half = this.meshSize / 2;
        String meshSeq = new String(MESH_SEQ);
        int meshSeqLn = meshSeq.length();
        StringBuilder gridStr = new StringBuilder(this.meshSize * 2);
        for (int i = 0; i < half; i += meshSeqLn) {
            gridStr.append(meshSeq);
        }
        StringBuilder reversedMeshSB = new StringBuilder(meshSeq);
        reversedMeshSB.reverse();
        String reversedMeshStr = reversedMeshSB.toString();
        for (int i = 0; i < half; i += meshSeqLn) {
            gridStr.append(reversedMeshStr);
        }
        return gridStr.toString().getBytes();
    }
    
    /**
     * Return the {@link #pellets}
     * @return the {@link #pellets}
     */
    public List<Pellet> getPellets() {
        return pellets;
    }

    /**
     * Set the {@link #pellets}
     * @param pellets The {@link #pellets} to be used
     */
    public void setPellets(List<Pellet> pellets) {
        this.pellets = pellets;
    }


    /**
     * Set the {@link #prolepticize} flag: true to apply a DRC meta-prolepticization tier to the matrix at build-time
     * @param prolepticize The {@link #prolepticize } value
     */
    public void setProlepticize(TrimodeBoolean prolepticize) {
        this.prolepticize = prolepticize;
    }

    /**
    * Reflect a list of {@link Pellet}s into the matrix, provoking each pellet sequentially.
    * @param pelletsList A list of {@link Pellet}s
    */
    @Override
    public void reflectPellets(List<Pellet> pelletsList) {
        this.pellets = pelletsList;
        int pelletsListSize = pelletsList.size();
        for (int i = 0; i < pelletsListSize; i++) {
            pelletsList.get(i).provoke();
        }

    }
    

    
}
